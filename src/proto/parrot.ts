// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "parrot.proto" (package "parrot.proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message parrot.proto.TakeConversation
 */
export interface TakeConversation {
    /**
     * @generated from protobuf field: string ConversationId = 1 [json_name = "ConversationId"];
     */
    conversationId: string;
    /**
     * @generated from protobuf field: string TenantUserId = 2 [json_name = "TenantUserId"];
     */
    tenantUserId: string;
}
/**
 * @generated from protobuf message parrot.proto.SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * @generated from protobuf field: string ConversationId = 1 [json_name = "ConversationId"];
     */
    conversationId: string;
    /**
     * @generated from protobuf field: string TenantUserId = 2 [json_name = "TenantUserId"];
     */
    tenantUserId: string;
    /**
     * @generated from protobuf field: string Content = 3 [json_name = "Content"];
     */
    content: string;
}
/**
 * @generated from protobuf message parrot.proto.MessagesRequest
 */
export interface MessagesRequest {
    /**
     * @generated from protobuf field: string ConversationId = 1 [json_name = "ConversationId"];
     */
    conversationId: string;
    /**
     * @generated from protobuf field: string IniDate = 2 [json_name = "IniDate"];
     */
    iniDate: string;
    /**
     * @generated from protobuf field: string EndDate = 3 [json_name = "EndDate"];
     */
    endDate: string;
}
/**
 * @generated from protobuf message parrot.proto.MessagesResponse
 */
export interface MessagesResponse {
    /**
     * @generated from protobuf field: repeated parrot.proto.Message Messages = 1 [json_name = "Messages"];
     */
    messages: Message[];
}
/**
 * @generated from protobuf message parrot.proto.Message
 */
export interface Message {
    /**
     * @generated from protobuf field: string Id = 1 [json_name = "Id"];
     */
    id: string;
    /**
     * @generated from protobuf field: string Role = 2 [json_name = "Role"];
     */
    role: string;
    /**
     * @generated from protobuf field: string Content = 3 [json_name = "Content"];
     */
    content: string;
    /**
     * @generated from protobuf field: string Status = 4 [json_name = "Status"];
     */
    status: string;
    /**
     * @generated from protobuf field: parrot.proto.TennantUser TenantUser = 5 [json_name = "TenantUser"];
     */
    tenantUser?: TennantUser;
}
/**
 * @generated from protobuf message parrot.proto.TennantUser
 */
export interface TennantUser {
    /**
     * @generated from protobuf field: string Id = 1 [json_name = "Id"];
     */
    id: string;
    /**
     * @generated from protobuf field: string TenantId = 2 [json_name = "TenantId"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * @generated from protobuf field: repeated parrot.proto.Contact Contacts = 4 [json_name = "Contacts"];
     */
    contacts: Contact[];
    /**
     * @generated from protobuf field: repeated parrot.proto.Address Addresses = 5 [json_name = "Addresses"];
     */
    addresses: Address[];
}
/**
 * @generated from protobuf message parrot.proto.ConversationRequest
 */
export interface ConversationRequest {
    /**
     * @generated from protobuf field: int64 Skip = 1 [json_name = "Skip"];
     */
    skip: bigint;
    /**
     * @generated from protobuf field: int64 Take = 2 [json_name = "Take"];
     */
    take: bigint;
    /**
     * @generated from protobuf field: string TenantId = 3 [json_name = "TenantId"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: repeated parrot.proto.KeyValue Filters = 4 [json_name = "Filters"];
     */
    filters: KeyValue[];
}
/**
 * @generated from protobuf message parrot.proto.KeyValue
 */
export interface KeyValue {
    /**
     * @generated from protobuf field: string Key = 1 [json_name = "Key"];
     */
    key: string;
    /**
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
}
/**
 * @generated from protobuf message parrot.proto.ConversationResponse
 */
export interface ConversationResponse {
    /**
     * @generated from protobuf field: repeated parrot.proto.Conversation Conversations = 1 [json_name = "Conversations"];
     */
    conversations: Conversation[];
    /**
     * @generated from protobuf field: int64 Count = 2 [json_name = "Count"];
     */
    count: bigint;
}
/**
 * @generated from protobuf message parrot.proto.Conversation
 */
export interface Conversation {
    /**
     * @generated from protobuf field: string Id = 1 [json_name = "Id"];
     */
    id: string;
    /**
     * @generated from protobuf field: parrot.proto.Tenant Tenant = 2 [json_name = "Tenant"];
     */
    tenant?: Tenant;
    /**
     * @generated from protobuf field: parrot.proto.User User = 3 [json_name = "User"];
     */
    user?: User;
    /**
     * @generated from protobuf field: string Status = 4 [json_name = "Status"];
     */
    status: string;
    /**
     * @generated from protobuf field: string CreationDate = 5 [json_name = "CreationDate"];
     */
    creationDate: string;
    /**
     * @generated from protobuf field: string LastUpdate = 6 [json_name = "LastUpdate"];
     */
    lastUpdate: string;
}
/**
 * @generated from protobuf message parrot.proto.Tenant
 */
export interface Tenant {
    /**
     * @generated from protobuf field: string Id = 1 [json_name = "Id"];
     */
    id: string;
    /**
     * @generated from protobuf field: string Name = 2 [json_name = "Name"];
     */
    name: string;
    /**
     * @generated from protobuf field: repeated parrot.proto.Contact Contacts = 3 [json_name = "Contacts"];
     */
    contacts: Contact[];
    /**
     * @generated from protobuf field: repeated parrot.proto.Address Addresses = 4 [json_name = "Addresses"];
     */
    addresses: Address[];
}
/**
 * @generated from protobuf message parrot.proto.Contact
 */
export interface Contact {
    /**
     * @generated from protobuf field: string Label = 1 [json_name = "Label"];
     */
    label: string;
    /**
     * @generated from protobuf field: string Contact = 2 [json_name = "Contact"];
     */
    contact: string;
}
/**
 * @generated from protobuf message parrot.proto.Address
 */
export interface Address {
    /**
     * @generated from protobuf field: string Label = 1 [json_name = "Label"];
     */
    label: string;
    /**
     * @generated from protobuf field: string Zipcode = 2 [json_name = "Zipcode"];
     */
    zipcode: string;
    /**
     * @generated from protobuf field: string Street = 3 [json_name = "Street"];
     */
    street: string;
    /**
     * @generated from protobuf field: string Number = 4 [json_name = "Number"];
     */
    number: string;
    /**
     * @generated from protobuf field: string District = 5 [json_name = "District"];
     */
    district: string;
    /**
     * @generated from protobuf field: string City = 6 [json_name = "City"];
     */
    city: string;
    /**
     * @generated from protobuf field: string State = 7 [json_name = "State"];
     */
    state: string;
}
/**
 * @generated from protobuf message parrot.proto.User
 */
export interface User {
    /**
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * @generated from protobuf field: string Phone = 2 [json_name = "Phone"];
     */
    phone: string;
    /**
     * @generated from protobuf field: repeated parrot.proto.KeyValue Informations = 3 [json_name = "Informations"];
     */
    informations: KeyValue[];
}
// @generated message type with reflection information, may provide speed optimized methods
class TakeConversation$Type extends MessageType<TakeConversation> {
    constructor() {
        super("parrot.proto.TakeConversation", [
            { no: 1, name: "ConversationId", kind: "scalar", jsonName: "ConversationId", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "TenantUserId", kind: "scalar", jsonName: "TenantUserId", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TakeConversation>): TakeConversation {
        const message = { conversationId: "", tenantUserId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeConversation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeConversation): TakeConversation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConversationId = 1 [json_name = "ConversationId"];*/ 1:
                    message.conversationId = reader.string();
                    break;
                case /* string TenantUserId = 2 [json_name = "TenantUserId"];*/ 2:
                    message.tenantUserId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeConversation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConversationId = 1 [json_name = "ConversationId"]; */
        if (message.conversationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.conversationId);
        /* string TenantUserId = 2 [json_name = "TenantUserId"]; */
        if (message.tenantUserId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenantUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.TakeConversation
 */
export const TakeConversation = new TakeConversation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageRequest$Type extends MessageType<SendMessageRequest> {
    constructor() {
        super("parrot.proto.SendMessageRequest", [
            { no: 1, name: "ConversationId", kind: "scalar", jsonName: "ConversationId", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "TenantUserId", kind: "scalar", jsonName: "TenantUserId", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Content", kind: "scalar", jsonName: "Content", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageRequest>): SendMessageRequest {
        const message = { conversationId: "", tenantUserId: "", content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageRequest): SendMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConversationId = 1 [json_name = "ConversationId"];*/ 1:
                    message.conversationId = reader.string();
                    break;
                case /* string TenantUserId = 2 [json_name = "TenantUserId"];*/ 2:
                    message.tenantUserId = reader.string();
                    break;
                case /* string Content = 3 [json_name = "Content"];*/ 3:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConversationId = 1 [json_name = "ConversationId"]; */
        if (message.conversationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.conversationId);
        /* string TenantUserId = 2 [json_name = "TenantUserId"]; */
        if (message.tenantUserId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenantUserId);
        /* string Content = 3 [json_name = "Content"]; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.SendMessageRequest
 */
export const SendMessageRequest = new SendMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessagesRequest$Type extends MessageType<MessagesRequest> {
    constructor() {
        super("parrot.proto.MessagesRequest", [
            { no: 1, name: "ConversationId", kind: "scalar", jsonName: "ConversationId", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "IniDate", kind: "scalar", jsonName: "IniDate", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "EndDate", kind: "scalar", jsonName: "EndDate", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessagesRequest>): MessagesRequest {
        const message = { conversationId: "", iniDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessagesRequest): MessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConversationId = 1 [json_name = "ConversationId"];*/ 1:
                    message.conversationId = reader.string();
                    break;
                case /* string IniDate = 2 [json_name = "IniDate"];*/ 2:
                    message.iniDate = reader.string();
                    break;
                case /* string EndDate = 3 [json_name = "EndDate"];*/ 3:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConversationId = 1 [json_name = "ConversationId"]; */
        if (message.conversationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.conversationId);
        /* string IniDate = 2 [json_name = "IniDate"]; */
        if (message.iniDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iniDate);
        /* string EndDate = 3 [json_name = "EndDate"]; */
        if (message.endDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.MessagesRequest
 */
export const MessagesRequest = new MessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessagesResponse$Type extends MessageType<MessagesResponse> {
    constructor() {
        super("parrot.proto.MessagesResponse", [
            { no: 1, name: "Messages", kind: "message", jsonName: "Messages", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }
        ]);
    }
    create(value?: PartialMessage<MessagesResponse>): MessagesResponse {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessagesResponse): MessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated parrot.proto.Message Messages = 1 [json_name = "Messages"];*/ 1:
                    message.messages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated parrot.proto.Message Messages = 1 [json_name = "Messages"]; */
        for (let i = 0; i < message.messages.length; i++)
            Message.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.MessagesResponse
 */
export const MessagesResponse = new MessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("parrot.proto.Message", [
            { no: 1, name: "Id", kind: "scalar", jsonName: "Id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Role", kind: "scalar", jsonName: "Role", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Content", kind: "scalar", jsonName: "Content", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Status", kind: "scalar", jsonName: "Status", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "TenantUser", kind: "message", jsonName: "TenantUser", T: () => TennantUser }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = { id: "", role: "", content: "", status: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Id = 1 [json_name = "Id"];*/ 1:
                    message.id = reader.string();
                    break;
                case /* string Role = 2 [json_name = "Role"];*/ 2:
                    message.role = reader.string();
                    break;
                case /* string Content = 3 [json_name = "Content"];*/ 3:
                    message.content = reader.string();
                    break;
                case /* string Status = 4 [json_name = "Status"];*/ 4:
                    message.status = reader.string();
                    break;
                case /* parrot.proto.TennantUser TenantUser = 5 [json_name = "TenantUser"];*/ 5:
                    message.tenantUser = TennantUser.internalBinaryRead(reader, reader.uint32(), options, message.tenantUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Id = 1 [json_name = "Id"]; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string Role = 2 [json_name = "Role"]; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* string Content = 3 [json_name = "Content"]; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        /* string Status = 4 [json_name = "Status"]; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        /* parrot.proto.TennantUser TenantUser = 5 [json_name = "TenantUser"]; */
        if (message.tenantUser)
            TennantUser.internalBinaryWrite(message.tenantUser, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TennantUser$Type extends MessageType<TennantUser> {
    constructor() {
        super("parrot.proto.TennantUser", [
            { no: 1, name: "Id", kind: "scalar", jsonName: "Id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "TenantId", kind: "scalar", jsonName: "TenantId", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Contacts", kind: "message", jsonName: "Contacts", repeat: 1 /*RepeatType.PACKED*/, T: () => Contact },
            { no: 5, name: "Addresses", kind: "message", jsonName: "Addresses", repeat: 1 /*RepeatType.PACKED*/, T: () => Address }
        ]);
    }
    create(value?: PartialMessage<TennantUser>): TennantUser {
        const message = { id: "", tenantId: "", name: "", contacts: [], addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TennantUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TennantUser): TennantUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Id = 1 [json_name = "Id"];*/ 1:
                    message.id = reader.string();
                    break;
                case /* string TenantId = 2 [json_name = "TenantId"];*/ 2:
                    message.tenantId = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* repeated parrot.proto.Contact Contacts = 4 [json_name = "Contacts"];*/ 4:
                    message.contacts.push(Contact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parrot.proto.Address Addresses = 5 [json_name = "Addresses"];*/ 5:
                    message.addresses.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TennantUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Id = 1 [json_name = "Id"]; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string TenantId = 2 [json_name = "TenantId"]; */
        if (message.tenantId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenantId);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated parrot.proto.Contact Contacts = 4 [json_name = "Contacts"]; */
        for (let i = 0; i < message.contacts.length; i++)
            Contact.internalBinaryWrite(message.contacts[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated parrot.proto.Address Addresses = 5 [json_name = "Addresses"]; */
        for (let i = 0; i < message.addresses.length; i++)
            Address.internalBinaryWrite(message.addresses[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.TennantUser
 */
export const TennantUser = new TennantUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConversationRequest$Type extends MessageType<ConversationRequest> {
    constructor() {
        super("parrot.proto.ConversationRequest", [
            { no: 1, name: "Skip", kind: "scalar", jsonName: "Skip", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "Take", kind: "scalar", jsonName: "Take", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "TenantId", kind: "scalar", jsonName: "TenantId", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Filters", kind: "message", jsonName: "Filters", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue }
        ]);
    }
    create(value?: PartialMessage<ConversationRequest>): ConversationRequest {
        const message = { skip: 0n, take: 0n, tenantId: "", filters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConversationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConversationRequest): ConversationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 Skip = 1 [json_name = "Skip"];*/ 1:
                    message.skip = reader.int64().toBigInt();
                    break;
                case /* int64 Take = 2 [json_name = "Take"];*/ 2:
                    message.take = reader.int64().toBigInt();
                    break;
                case /* string TenantId = 3 [json_name = "TenantId"];*/ 3:
                    message.tenantId = reader.string();
                    break;
                case /* repeated parrot.proto.KeyValue Filters = 4 [json_name = "Filters"];*/ 4:
                    message.filters.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConversationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 Skip = 1 [json_name = "Skip"]; */
        if (message.skip !== 0n)
            writer.tag(1, WireType.Varint).int64(message.skip);
        /* int64 Take = 2 [json_name = "Take"]; */
        if (message.take !== 0n)
            writer.tag(2, WireType.Varint).int64(message.take);
        /* string TenantId = 3 [json_name = "TenantId"]; */
        if (message.tenantId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tenantId);
        /* repeated parrot.proto.KeyValue Filters = 4 [json_name = "Filters"]; */
        for (let i = 0; i < message.filters.length; i++)
            KeyValue.internalBinaryWrite(message.filters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.ConversationRequest
 */
export const ConversationRequest = new ConversationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyValue$Type extends MessageType<KeyValue> {
    constructor() {
        super("parrot.proto.KeyValue", [
            { no: 1, name: "Key", kind: "scalar", jsonName: "Key", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyValue>): KeyValue {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyValue): KeyValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Key = 1 [json_name = "Key"];*/ 1:
                    message.key = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Key = 1 [json_name = "Key"]; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.KeyValue
 */
export const KeyValue = new KeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConversationResponse$Type extends MessageType<ConversationResponse> {
    constructor() {
        super("parrot.proto.ConversationResponse", [
            { no: 1, name: "Conversations", kind: "message", jsonName: "Conversations", repeat: 1 /*RepeatType.PACKED*/, T: () => Conversation },
            { no: 2, name: "Count", kind: "scalar", jsonName: "Count", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ConversationResponse>): ConversationResponse {
        const message = { conversations: [], count: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConversationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConversationResponse): ConversationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated parrot.proto.Conversation Conversations = 1 [json_name = "Conversations"];*/ 1:
                    message.conversations.push(Conversation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 Count = 2 [json_name = "Count"];*/ 2:
                    message.count = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConversationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated parrot.proto.Conversation Conversations = 1 [json_name = "Conversations"]; */
        for (let i = 0; i < message.conversations.length; i++)
            Conversation.internalBinaryWrite(message.conversations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 Count = 2 [json_name = "Count"]; */
        if (message.count !== 0n)
            writer.tag(2, WireType.Varint).int64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.ConversationResponse
 */
export const ConversationResponse = new ConversationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Conversation$Type extends MessageType<Conversation> {
    constructor() {
        super("parrot.proto.Conversation", [
            { no: 1, name: "Id", kind: "scalar", jsonName: "Id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Tenant", kind: "message", jsonName: "Tenant", T: () => Tenant },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => User },
            { no: 4, name: "Status", kind: "scalar", jsonName: "Status", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "CreationDate", kind: "scalar", jsonName: "CreationDate", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "LastUpdate", kind: "scalar", jsonName: "LastUpdate", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Conversation>): Conversation {
        const message = { id: "", status: "", creationDate: "", lastUpdate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Conversation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Conversation): Conversation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Id = 1 [json_name = "Id"];*/ 1:
                    message.id = reader.string();
                    break;
                case /* parrot.proto.Tenant Tenant = 2 [json_name = "Tenant"];*/ 2:
                    message.tenant = Tenant.internalBinaryRead(reader, reader.uint32(), options, message.tenant);
                    break;
                case /* parrot.proto.User User = 3 [json_name = "User"];*/ 3:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* string Status = 4 [json_name = "Status"];*/ 4:
                    message.status = reader.string();
                    break;
                case /* string CreationDate = 5 [json_name = "CreationDate"];*/ 5:
                    message.creationDate = reader.string();
                    break;
                case /* string LastUpdate = 6 [json_name = "LastUpdate"];*/ 6:
                    message.lastUpdate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Conversation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Id = 1 [json_name = "Id"]; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* parrot.proto.Tenant Tenant = 2 [json_name = "Tenant"]; */
        if (message.tenant)
            Tenant.internalBinaryWrite(message.tenant, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* parrot.proto.User User = 3 [json_name = "User"]; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Status = 4 [json_name = "Status"]; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        /* string CreationDate = 5 [json_name = "CreationDate"]; */
        if (message.creationDate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.creationDate);
        /* string LastUpdate = 6 [json_name = "LastUpdate"]; */
        if (message.lastUpdate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.lastUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.Conversation
 */
export const Conversation = new Conversation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tenant$Type extends MessageType<Tenant> {
    constructor() {
        super("parrot.proto.Tenant", [
            { no: 1, name: "Id", kind: "scalar", jsonName: "Id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Contacts", kind: "message", jsonName: "Contacts", repeat: 1 /*RepeatType.PACKED*/, T: () => Contact },
            { no: 4, name: "Addresses", kind: "message", jsonName: "Addresses", repeat: 1 /*RepeatType.PACKED*/, T: () => Address }
        ]);
    }
    create(value?: PartialMessage<Tenant>): Tenant {
        const message = { id: "", name: "", contacts: [], addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tenant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tenant): Tenant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Id = 1 [json_name = "Id"];*/ 1:
                    message.id = reader.string();
                    break;
                case /* string Name = 2 [json_name = "Name"];*/ 2:
                    message.name = reader.string();
                    break;
                case /* repeated parrot.proto.Contact Contacts = 3 [json_name = "Contacts"];*/ 3:
                    message.contacts.push(Contact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parrot.proto.Address Addresses = 4 [json_name = "Addresses"];*/ 4:
                    message.addresses.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tenant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Id = 1 [json_name = "Id"]; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string Name = 2 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated parrot.proto.Contact Contacts = 3 [json_name = "Contacts"]; */
        for (let i = 0; i < message.contacts.length; i++)
            Contact.internalBinaryWrite(message.contacts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated parrot.proto.Address Addresses = 4 [json_name = "Addresses"]; */
        for (let i = 0; i < message.addresses.length; i++)
            Address.internalBinaryWrite(message.addresses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.Tenant
 */
export const Tenant = new Tenant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contact$Type extends MessageType<Contact> {
    constructor() {
        super("parrot.proto.Contact", [
            { no: 1, name: "Label", kind: "scalar", jsonName: "Label", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Contact", kind: "scalar", jsonName: "Contact", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Contact>): Contact {
        const message = { label: "", contact: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Contact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contact): Contact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Label = 1 [json_name = "Label"];*/ 1:
                    message.label = reader.string();
                    break;
                case /* string Contact = 2 [json_name = "Contact"];*/ 2:
                    message.contact = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Label = 1 [json_name = "Label"]; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string Contact = 2 [json_name = "Contact"]; */
        if (message.contact !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contact);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.Contact
 */
export const Contact = new Contact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Address$Type extends MessageType<Address> {
    constructor() {
        super("parrot.proto.Address", [
            { no: 1, name: "Label", kind: "scalar", jsonName: "Label", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Zipcode", kind: "scalar", jsonName: "Zipcode", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Street", kind: "scalar", jsonName: "Street", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Number", kind: "scalar", jsonName: "Number", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "District", kind: "scalar", jsonName: "District", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "City", kind: "scalar", jsonName: "City", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "State", kind: "scalar", jsonName: "State", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Address>): Address {
        const message = { label: "", zipcode: "", street: "", number: "", district: "", city: "", state: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Address): Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Label = 1 [json_name = "Label"];*/ 1:
                    message.label = reader.string();
                    break;
                case /* string Zipcode = 2 [json_name = "Zipcode"];*/ 2:
                    message.zipcode = reader.string();
                    break;
                case /* string Street = 3 [json_name = "Street"];*/ 3:
                    message.street = reader.string();
                    break;
                case /* string Number = 4 [json_name = "Number"];*/ 4:
                    message.number = reader.string();
                    break;
                case /* string District = 5 [json_name = "District"];*/ 5:
                    message.district = reader.string();
                    break;
                case /* string City = 6 [json_name = "City"];*/ 6:
                    message.city = reader.string();
                    break;
                case /* string State = 7 [json_name = "State"];*/ 7:
                    message.state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Label = 1 [json_name = "Label"]; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string Zipcode = 2 [json_name = "Zipcode"]; */
        if (message.zipcode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.zipcode);
        /* string Street = 3 [json_name = "Street"]; */
        if (message.street !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.street);
        /* string Number = 4 [json_name = "Number"]; */
        if (message.number !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.number);
        /* string District = 5 [json_name = "District"]; */
        if (message.district !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.district);
        /* string City = 6 [json_name = "City"]; */
        if (message.city !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.city);
        /* string State = 7 [json_name = "State"]; */
        if (message.state !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.Address
 */
export const Address = new Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("parrot.proto.User", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Phone", kind: "scalar", jsonName: "Phone", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Informations", kind: "message", jsonName: "Informations", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { name: "", phone: "", informations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Phone = 2 [json_name = "Phone"];*/ 2:
                    message.phone = reader.string();
                    break;
                case /* repeated parrot.proto.KeyValue Informations = 3 [json_name = "Informations"];*/ 3:
                    message.informations.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Phone = 2 [json_name = "Phone"]; */
        if (message.phone !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.phone);
        /* repeated parrot.proto.KeyValue Informations = 3 [json_name = "Informations"]; */
        for (let i = 0; i < message.informations.length; i++)
            KeyValue.internalBinaryWrite(message.informations[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parrot.proto.User
 */
export const User = new User$Type();
/**
 * @generated ServiceType for protobuf service parrot.proto.ConversationService
 */
export const ConversationService = new ServiceType("parrot.proto.ConversationService", [
    { name: "GetAllConversations", serverStreaming: true, options: {}, I: ConversationRequest, O: ConversationResponse },
    { name: "TakeOverConversation", options: {}, I: TakeConversation, O: TakeConversation }
]);
/**
 * @generated ServiceType for protobuf service parrot.proto.MessageService
 */
export const MessageService = new ServiceType("parrot.proto.MessageService", [
    { name: "GetMessagesByConversationId", serverStreaming: true, options: {}, I: MessagesRequest, O: MessagesResponse },
    { name: "SendMessage", options: {}, I: SendMessageRequest, O: Message }
]);
